<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <title>Galaxy ‚Äî Fast Spiral ‚ú®</title>
   <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#000000">
  <style>
    html, body { height:100%; margin:0; background:#000; overflow:hidden; }
    #tip {
      position:fixed; left:12px; bottom:12px; color:#fff;
      font:14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; opacity:.9; z-index:2;
    }
    #hud {
      position:fixed; right:12px; top:12px; display:flex; gap:8px; z-index:2;
    }
    .btn {
      background: rgba(255,255,255,.08); color:#fff; border:0;
      padding:8px 12px; border-radius:999px; cursor:pointer; font:13px system-ui;
    }
    .btn:active { transform: translateY(1px) }
  </style>
</head>
<body>
  <div id="tip">K√©o ƒë·ªÉ xoay, ch·ª•m 2 ng√≥n ƒë·ªÉ zoom ‚Ä¢ <a href="birthday.html" style="color:#fff">Quay l·∫°i</a></div>
  <div id="hud">
    <button class="btn" id="speed">‚ö° Nhanh</button>
    <button class="btn" id="pulse">‚ú® Pulse</button>
    <button class="btn" id="reset">‚Ü∫ Reset</button>
  </div>
  <canvas id="cv"></canvas>

<script>
/* ========= Canvas & DPR ========= */
const cv = document.getElementById('cv');
const cx = cv.getContext('2d', { alpha: false });
let DPR = Math.min( (window.devicePixelRatio||1), 1.75 ); // cap DPR cho mobile ƒë·ª° n·∫∑ng

function resize(){
  cv.width = Math.max(1, Math.floor(innerWidth  * DPR));
  cv.height= Math.max(1, Math.floor(innerHeight * DPR));
  cv.style.width = innerWidth + 'px';
  cv.style.height= innerHeight + 'px';
  cx.setTransform(DPR,0,0,DPR,0,0);
}
addEventListener('resize', resize);
addEventListener('orientationchange', resize);
resize();

/* ========= Perf preset cho m√°y y·∫øu ========= */
const mem = navigator.deviceMemory || 4;
const LOW = mem <= 4 && innerWidth < 900; // m√°y y·∫øu ho·∫∑c m√†n nh·ªè
const STAR_COUNT = LOW ? 1800 : 3200;     // gi·∫£m b·ªõt h·∫°t cho mobile
const R_MAX = 420;
const THICKNESS = 22;
const ORBIT_SPRITES = 18;

let autoSpeed = 0.017;
let userRotY = 0.0, userRotX = 0.18, dist = 520;

/* ========= Galaxy points ========= */
const points = [];
for (let i=0;i<STAR_COUNT;i++){
  const radius = Math.pow(Math.random(), 0.55) * R_MAX;
  const arms = 4;
  const baseAngle = Math.random() * Math.PI * 2;
  const twist = radius * 0.17;
  const angle = baseAngle + Math.floor(Math.random()*arms) * (Math.PI*2/arms) + twist;

  const y = (Math.random()-0.5) * THICKNESS;
  const x = Math.cos(angle) * radius;
  const z = Math.sin(angle) * radius;

  // HUE ‚Äúng√¢n h√† huy·ªÅn b√≠‚Äù: map 200‚Äì320¬∞, c√≥ tr√¥i m√†u theo th·ªùi gian
  const hueBase = 200 + (angle/(Math.PI*2))*120; // 200‚Üí320
  const sat = 88;
  const light = 55 + Math.random()*12;
  points.push({x,y,z,hueBase,sat,light});
}

/* ========= Starfield xa ========= */
const stars = Array.from({length: LOW ? 900 : 1400}, ()=> ({
  x:(Math.random()-0.5)*2600,
  y:(Math.random()-0.5)*1600,
  z: Math.random()*2400 + 400
}));

/* ========= Orbiting sprites (·∫£nh ng∆∞·ªùi d√πng n·∫øu c√≥) ========= */
const spriteImg = new Image();
(function chooseSprite(){
  const user = localStorage.getItem('userImageDataUrl');
  if (user) { spriteImg.src = user; return; }
  const tryList = ['assets/OIP.webp','assets/OIP.png','assets/abc.jpg','assets/cute.svg'];
  spriteImg.src = tryList.find(Boolean);
})();

/* ========= Orbit params ========= */
const sprites = [];
for(let i=0;i<ORBIT_SPRITES;i++){
  const a = i / ORBIT_SPRITES * Math.PI*2;
  const r = 260 + Math.sin(i*0.7)*18;
  sprites.push({a, r, y: (Math.random()-0.5)*30, s: 0.8 + Math.random()*0.6});
}

/* ========= ƒêi·ªÅu khi·ªÉn: chu·ªôt + c·∫£m ·ª©ng ========= */
let dragging = false, px=0, py=0;

cv.addEventListener('mousedown', e=>{ dragging=true; px=e.clientX; py=e.clientY; });
addEventListener('mouseup',   ()=> dragging=false);
addEventListener('mousemove', e=>{
  if(!dragging) return;
  const dx = e.clientX - px, dy = e.clientY - py; px = e.clientX; py = e.clientY;
  userRotY += dx * 0.006;
  userRotX += dy * 0.006;
  userRotX = Math.max(-1.2, Math.min(1.2, userRotX));
});
addEventListener('wheel', e=>{
  dist = Math.max(220, Math.min(920, dist + e.deltaY * 0.4));
}, {passive:true});

// Touch: 1 ng√≥n xoay, 2 ng√≥n pinch-zoom
let lastPinch = null;
cv.addEventListener('touchstart', e=>{
  if(e.touches.length===1){ dragging=true; px=e.touches[0].clientX; py=e.touches[0].clientY; }
  if(e.touches.length===2){
    const [a,b] = e.touches; lastPinch = Math.hypot(a.clientX-b.clientX, a.clientY-b.clientY);
  }
}, {passive:true});

cv.addEventListener('touchmove', e=>{
  if(e.touches.length===1 && dragging){
    const t = e.touches[0];
    const dx = t.clientX - px, dy = t.clientY - py; px = t.clientX; py = t.clientY;
    userRotY += dx * 0.006;
    userRotX += dy * 0.006;
    userRotX = Math.max(-1.2, Math.min(1.2, userRotX));
  }
  if(e.touches.length===2){
    const [a,b] = e.touches;
    const d = Math.hypot(a.clientX-b.clientX, a.clientY-b.clientY);
    if(lastPinch != null){
      const delta = d - lastPinch; // >0 l√† t√°ch ra (zoom in)
      dist = Math.max(220, Math.min(920, dist - delta*0.6));
    }
    lastPinch = d;
  }
}, {passive:true});

cv.addEventListener('touchend', ()=>{
  dragging=false; lastPinch=null;
}, {passive:true});

/* ========= Helpers ========= */
function proj(x,y,z){
  const cY = Math.cos(userRotY), sY = Math.sin(userRotY);
  const cX = Math.cos(userRotX), sX = Math.sin(userRotX);
  let X = x*cY - z*sY;
  let Z = x*sY + z*cY;
  let Y = y*cX - Z*sX;
  Z = y*sX + Z*cX + dist;
  const f = 450 / Z;
  return { x: innerWidth/2 + X*f, y: innerHeight/2 + Y*f, s: f, Z };
}

/* ========= ORB trung t√¢m ƒë·ªông (pulsate + sparkle nh∆∞ GIF) ========= */
const orbSparkles = Array.from({length: 80}, (_,i)=>({
  a: Math.random()*Math.PI*2,    // g√≥c
  r: 40 + Math.random()*110,     // b√°n k√≠nh
  s: 0.6 + Math.random()*1.6,    // k√≠ch th∆∞·ªõc c∆° s·ªü
  o: Math.random()*1000 + i*13   // l·ªách pha nh·∫•p nh√°y
}));
function drawOrb(t){
  const cx0 = innerWidth/2, cy0 = innerHeight/2;

  // pulsate radius + hue drift
  const k = 0.5 + 0.5*Math.sin(t*0.07);
  const R = 90 + 18*k;                         // b√°n k√≠nh ƒë·ªông
  const hue = (260 + 30*Math.sin(t*0.04))%360; // t√≠m ‚Üí xanh lam tr√¥i nh·∫π

  // l√µi s√°ng
  const g1 = cx.createRadialGradient(cx0, cy0, 0, cx0, cy0, R);
  g1.addColorStop(0, 'rgba(255,255,255,0.95)');
  g1.addColorStop(0.45, `hsla(${hue}, 90%, 70%, 0.85)`);
  g1.addColorStop(1, 'rgba(255,255,255,0)');
  cx.fillStyle = g1;
  cx.beginPath(); cx.arc(cx0, cy0, R, 0, Math.PI*2); cx.fill();

  // h√†o quang ngo√†i (screen)
  const g2 = cx.createRadialGradient(cx0, cy0, R*0.9, cx0, cy0, R*1.9);
  g2.addColorStop(0, `hsla(${(hue+40)%360}, 90%, 60%, 0.25)`);
  g2.addColorStop(1, 'rgba(0,0,0,0)');
  cx.globalCompositeOperation = 'screen';
  cx.fillStyle = g2; cx.beginPath(); cx.arc(cx0, cy0, R*2, 0, Math.PI*2); cx.fill();

  // v√†i tia s√°ng quay ch·∫≠m
  cx.save();
  cx.translate(cx0, cy0);
  cx.rotate(t*0.01);
  for(let i=0;i<6;i++){
    cx.rotate(Math.PI/3);
    const grd = cx.createLinearGradient(0, -R*1.6, 0, R*1.6);
    grd.addColorStop(0, 'rgba(255,255,255,0)');
    grd.addColorStop(0.5, `hsla(${(hue+20)%360}, 100%, 70%, 0.23)`);
    grd.addColorStop(1, 'rgba(255,255,255,0)');
    cx.fillStyle = grd;
    cx.beginPath();
    cx.moveTo(-2.2, -R*1.6);
    cx.lineTo( 2.2, -R*1.6);
    cx.lineTo( 0.8,  R*1.6);
    cx.lineTo(-0.8,  R*1.6);
    cx.closePath(); cx.fill();
  }
  cx.restore();

  // sparkle h·∫°t quanh orb (flicker)
  cx.globalCompositeOperation = 'lighter';
  for(const sp of orbSparkles){
    const tw = 0.6 + 0.4*Math.sin((t+sp.o)*0.12);
    const a = sp.a + t*0.005;
    const x = cx0 + Math.cos(a)*sp.r;
    const y = cy0 + Math.sin(a)*sp.r*0.85;
    cx.globalAlpha = 0.5 + 0.5*tw;
    cx.beginPath(); cx.arc(x, y, sp.s*tw, 0, Math.PI*2); cx.fillStyle = `hsla(${(hue+60)%360}, 100%, 70%, 0.9)`; cx.fill();
  }
  cx.globalAlpha = 1;
  cx.globalCompositeOperation = 'source-over';
}

/* ========= Animation ========= */
let t = 0, pulsing = false, running = true;
document.addEventListener('visibilitychange', ()=>{ running = !document.hidden; });

let sortToggle = 0; // gi·∫£m s·ªë l·∫ßn sort cho nh·∫π
(function loop(){
  requestAnimationFrame(loop);
  if(!running) return;

  t += 1;
  userRotY += autoSpeed;

  /* ===== N·ªÄN: gradient v≈© tr·ª• t√≠m‚Äìxanh (mystic) ===== */
  const gx = innerWidth*0.6, gy = innerHeight*0.5, gr = Math.max(innerWidth,innerHeight);
  const bg = cx.createRadialGradient(gx, gy, 0, gx, gy, gr);
  bg.addColorStop(0,  'rgba(40, 70,130,0.40)');  // xanh ƒë·∫≠m
  bg.addColorStop(0.55,'rgba(20, 13, 34,0.75)'); // t√≠m than
  bg.addColorStop(1,  'rgba(0,  0,  0,1)');
  cx.fillStyle = bg; cx.fillRect(0,0,innerWidth,innerHeight);

  // Sao xa
  cx.globalCompositeOperation = 'source-over';
  cx.fillStyle = '#fff';
  cx.globalAlpha = 0.7;
  for(const s of stars){
    const p = proj(s.x, s.y, s.z);
    const r = Math.max(.4, 1.2*p.s);
    cx.beginPath(); cx.arc(p.x, p.y, r, 0, Math.PI*2); cx.fill();
  }
  cx.globalAlpha = 1;

  // ORB trung t√¢m ƒë·ªông (thay cho orb tƒ©nh c≈©)
  drawOrb(t);

  // Xo√°y galaxy (additive)
  cx.globalCompositeOperation = 'lighter';

  // ch·ªâ sort m·ªói 2 frame ƒë·ªÉ ti·∫øt ki·ªám
  let drawList = points;
  if ((sortToggle^=1)) {
    drawList = points.slice().sort((a,b)=>{
      const za = a.x*Math.sin(userRotY)+a.z*Math.cos(userRotY);
      const zb = b.x*Math.sin(userRotY)+b.z*Math.cos(userRotY);
      return za - zb;
    });
  }

  const pulse = pulsing ? (1 + Math.sin(t*0.06)*0.06) : 1;

  for(const p of drawList){
    const wobble = Math.sin((p.x+p.z+t*0.8)*0.01)*0.5;
    const pr = proj(p.x * pulse, (p.y+wobble) * pulse, p.z * pulse);

    // Tr√¥i m√†u theo th·ªùi gian ƒë·ªÉ ‚Äúhuy·ªÅn b√≠‚Äù
    const hue = (p.hueBase + 20*Math.sin(t*0.02)) % 360;
    const size = Math.min(2.8, 1.8*pr.s + 0.6);
    cx.fillStyle = `hsla(${hue}, ${p.sat}%, ${p.light}%, 0.95)`;
    cx.beginPath(); cx.arc(pr.x, pr.y, size, 0, Math.PI*2); cx.fill();
  }

  // V√≤ng ·∫£nh
  const ordered = sprites; // s·ªë l∆∞·ª£ng √≠t n√™n kh·ªèi sort
  for(const sp of ordered){
    const a = sp.a + t*(0.028 + sp.s*0.004); // h∆°i ch·∫≠m l·∫°i x√≠u ƒë·ªÉ h·ª£p kh√¥ng kh√≠
    const r = sp.r;
    const p = proj(Math.cos(a)*r, sp.y, Math.sin(a)*r);
    const w = 44*sp.s*p.s, h = w;
    const rr = Math.min(10*p.s, w/4);
    cx.save();
    cx.translate(p.x, p.y);
    cx.globalCompositeOperation = 'lighter';
    cx.fillStyle = 'rgba(255,255,255,0.12)';
    roundRect(cx, -w/2, -h/2, w, h, rr); cx.fill();

    if (spriteImg.complete && w>2 && h>2) {
      cx.globalCompositeOperation = 'source-over';
      cx.save(); roundRect(cx, -w/2, -h/2, w, h, rr); cx.clip();
      cx.drawImage(spriteImg, -w/2, -h/2, w, h);
      cx.restore();
    }
    cx.restore();
  }

  cx.globalCompositeOperation = 'source-over';
})();

/* ========= UI Buttons ========= */
document.getElementById('speed').addEventListener('click', ()=>{
  if (autoSpeed >= 0.03) { autoSpeed = 0.006;  document.getElementById('speed').textContent = '‚è≥ Ch·∫≠m'; }
  else if (autoSpeed >= 0.017) { autoSpeed = 0.03; document.getElementById('speed').textContent = 'üöÄ R·∫•t nhanh'; }
  else { autoSpeed = 0.017; document.getElementById('speed').textContent = '‚ö° Nhanh'; }
});
document.getElementById('pulse').addEventListener('click', ()=>{
  pulsing = !pulsing;
  document.getElementById('pulse').textContent = pulsing ? '‚ú® Pulse ‚úì' : '‚ú® Pulse';
});
document.getElementById('reset').addEventListener('click', ()=>{
  userRotY = 0.0; userRotX = 0.18; dist = 520;
});

/* ========= Helper ========= */
function roundRect(ctx, x, y, w, h, r){
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y,   x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x,   y+h, r);
  ctx.arcTo(x,   y+h, x,   y,   r);
  ctx.arcTo(x,   y,   x+w, y,   r);
  ctx.closePath();
}
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./sw.js').catch(()=>{});
}

</script>
</body>
</html>