<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <title>Galaxy ‚Äî Birthday Orbit ‚ú®</title>
  <meta name="theme-color" content="#000000">
  <style>
    html, body {
      height:100%;
      margin:0;
      background:#000;
      overflow:hidden;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
    }

    /* Canvas v≈© tr·ª• */
    #cv{
      position:fixed;
      inset:0;
      z-index:1;
      display:block;
      background:#000;
    }

    /* L·ªùi ch√∫c */
    #wishBox{
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:24px;
      text-align:center;

      font-family: "Dancing Script", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
      font-size:clamp(24px,4vw,40px);
      line-height:1.3;
      color:#fff;

      text-shadow:
        0 0 12px rgba(255,100,200,1),
        0 0 28px rgba(255,0,120,0.8),
        0 4px 10px rgba(0,0,0,.8);

      background: radial-gradient(
        circle at 50% 50%,
        rgba(0,0,0,0.6) 0%,
        rgba(0,0,0,0.0) 60%
      );

      pointer-events:none;
      opacity:0;
      transition: opacity .8s ease;
      z-index:5;
    }
  </style>
</head>
<body>

  <div id="wishBox"></div>
  <canvas id="cv"></canvas>

<script>
/* =========================================================
   ========== 1. IndexedDB helper (gi·ªëng storage.js) ========
   ========================================================= */

const DB_NAME = 'birthdayDB';
const DB_VER  = 1;
const STORE   = 'images';

function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VER);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) {
        db.createObjectStore(STORE); // simple key-value
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror   = () => reject(req.error);
  });
}

// get blob by key
async function getImageFromDB(key) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const req = tx.objectStore(STORE).get(key);
    req.onsuccess = () => resolve(req.result || null);
    req.onerror   = () => reject(req.error);
  });
}

// load all galaxy blobs -> array of objectURLs
async function loadAllGalaxyImages() {
  const keys = [
    'img_galaxy_1',
    'img_galaxy_2',
    'img_galaxy_3',
    'img_galaxy_4',
    'img_galaxy_5'
  ];
  const out = [];
  for (const k of keys) {
    const blob = await getImageFromDB(k);
    if (blob) {
      out.push(URL.createObjectURL(blob));
    }
  }
  if (out.length === 0) {
    // fallback n·∫øu user ch∆∞a ch·ªçn ·∫£nh
    out.push('assets/cute-cake.png');
  }
  return out;
}

/* =========================================================
   ========== 2. Setup wish text / canvas / params =========
   ========================================================= */

const wishEl = document.getElementById('wishBox');

// L·ªùi ch√∫c t·ª´ localStorage
const savedWish = localStorage.getItem('wish_text')
  || "Ch√∫c m·ª´ng sinh nh·∫≠t üéÇ Ch√∫c b·∫°n lu√¥n xinh ƒë·∫πp, h·∫°nh ph√∫c v√† ƒë∆∞·ª£c y√™u th∆∞∆°ng nh·∫•t v≈© tr·ª• üíñ‚ú®";

wishEl.textContent = savedWish;
// delay hi·ªán l·ªùi ch√∫c ƒë·ªÉ t·∫°o moment
setTimeout(()=> {
  wishEl.style.opacity = 1;
}, 10000);

const cv = document.getElementById('cv');
const cx = cv.getContext('2d', { alpha: false });

let DPR = Math.min((window.devicePixelRatio||1), 1.75);
function resize(){
  cv.width  = Math.max(1, Math.floor(innerWidth  * DPR));
  cv.height = Math.max(1, Math.floor(innerHeight * DPR));
  cv.style.width  = innerWidth + 'px';
  cv.style.height = innerHeight + 'px';
  cx.setTransform(DPR,0,0,DPR,0,0);
}
addEventListener('resize', resize);
resize();

/* Perf preset */
const mem = navigator.deviceMemory || 4;
const LOW = mem <= 4 && innerWidth < 900;

const STAR_COUNT    = LOW ? 1800 : 3200;
const R_MAX         = 420;
const THICKNESS     = 22;
const ORBIT_SPRITES = 8;  // s·ªë "th·∫ª" bay quanh (slot hi·ªÉn th·ªã), ch√∫ng s·∫Ω loop qua list ·∫£nh

/* camera-ish */
let autoSpeed = 0.01;
let userRotY = 0.0;
let userRotX = 0.18;
const dist = 520;

/* =========================================================
   ========== 3. Galaxy point cloud / stars =================
   ========================================================= */

// d·∫£i ng√¢n h√† (ƒë√°m b·ª•i m√†u)
const points = [];
for (let i=0; i<STAR_COUNT; i++){
  const radius    = Math.pow(Math.random(), 0.55) * R_MAX;
  const arms      = 4;
  const baseAngle = Math.random() * Math.PI * 2;
  const twist     = radius * 0.17;
  const angle     = baseAngle
                  + Math.floor(Math.random()*arms) * (Math.PI*2/arms)
                  + twist;

  const y = (Math.random()-0.5) * THICKNESS;
  const x = Math.cos(angle) * radius;
  const z = Math.sin(angle) * radius;

  const hueBase = 200 + (angle/(Math.PI*2))*120;
  const sat     = 88;
  const light   = 55 + Math.random()*12;

  points.push({x,y,z,hueBase,sat,light});
}

// sao xa ph√≠a sau
const stars = Array.from({length: LOW ? 900 : 1400}, () => ({
  x:(Math.random()-0.5)*2600,
  y:(Math.random()-0.5)*1600,
  z: Math.random()*2400 + 400
}));

/* =========================================================
   ========== 4. Sprites (·∫£nh quay quanh) ==================
   =========================================================
   Ch√∫ng ta s·∫Ω kh·ªüi t·∫°o SAU khi load ·∫£nh (async)
*/

let spriteImgs = [];  // m·∫£ng Image() t∆∞∆°ng ·ª©ng c√°c ·∫£nh galaxy
let sprites    = [];  // m·ªói slot bay quanh c√≥ {imgIndex, baseA, r, y, s}

/* =========================================================
   ========== 5. Input drag ƒë·ªÉ xoay ========================
   ========================================================= */
let dragging=false, px=0, py=0;

cv.addEventListener('mousedown', e=>{
  dragging=true; px=e.clientX; py=e.clientY;
});
addEventListener('mouseup', ()=> dragging=false);
addEventListener('mousemove', e=>{
  if(!dragging) return;
  const dx=e.clientX-px, dy=e.clientY-py;
  px=e.clientX; py=e.clientY;
  userRotY += dx*0.006;
  userRotX += dy*0.006;
  userRotX = Math.max(-1.2, Math.min(1.2, userRotX));
});

cv.addEventListener('touchstart', e=>{
  if(e.touches.length===1){
    dragging=true;
    px=e.touches[0].clientX;
    py=e.touches[0].clientY;
  }
},{passive:true});

cv.addEventListener('touchmove', e=>{
  if(e.touches.length===1 && dragging){
    const t0=e.touches[0];
    const dx=t0.clientX-px, dy=t0.clientY-py;
    px=t0.clientX; py=t0.clientY;
    userRotY+=dx*0.006;
    userRotX+=dy*0.006;
    userRotX=Math.max(-1.2,Math.min(1.2,userRotX));
  }
},{passive:true});

cv.addEventListener('touchend', ()=>{ dragging=false; },{passive:true});

/* =========================================================
   ========== 6. Math chi·∫øu 3D -> 2D =======================
   ========================================================= */
function proj(x,y,z){
  const cY = Math.cos(userRotY), sY = Math.sin(userRotY);
  const cX = Math.cos(userRotX), sX = Math.sin(userRotX);

  let X = x*cY - z*sY;
  let Z = x*sY + z*cY;
  let Y = y*cX - Z*sX;
  Z = y*sX + Z*cX + dist;

  const f = 450 / Z;
  return {
    x: innerWidth/2  + X*f,
    y: innerHeight/2 + Y*f,
    s: f
  };
}

/* =========================================================
   ========== 7. Spotlight logic ===========================
   =========================================================
   mode "orbit": t·∫•t c·∫£ th·∫ª ·∫£nh quay quanh
   mode "spotlight": d·ª´ng quay, l·∫•y 1 ·∫£nh ph√≥ng to gi·ªØa m√†n h√¨nh.
*/

let mode = "orbit";
let tOrbit = 0;
let orbitFrameCounter = 0;
const ORBIT_FRAMES_BEFORE_SPOTLIGHT = 20; // kho·∫£ng ~4s n·∫øu ~60fps

let spotlightFrameCounter = 0;
const SPOTLIGHT_FRAMES = 10; // ~2s ƒë·ª©ng im

let spotlightSpriteIndex = 0;     // slot sprite ƒëang ƒë∆∞·ª£c spotlight
let nextSpotlightSpriteIndex = 1; // slot k·∫ø ti·∫øp
let spotlightImageScale = 1;      // scale t·∫•m ·∫£nh khi ch·ª•p spotlight

/* =========================================================
   ========== 8. RoundRect helper ==========================
   ========================================================= */
function roundRect(ctx, x, y, w, h, r){
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y,   x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x,   y+h, r);
  ctx.arcTo(x,   y+h, x,   y,   r);
  ctx.arcTo(x,   y,   x+w, y,   r);
  ctx.closePath();
}

/* =========================================================
   ========== 9. Main render loop ==========================
   ========================================================= */
let sortToggle = 0;
let pulsing = false;

function drawCoreGlow(){
  const cxMid = innerWidth/2;
  const cyMid = innerHeight/2;

  // √°nh s√°ng trung t√¢m
  const g1 = cx.createRadialGradient(cxMid, cyMid, 0, cxMid, cyMid, innerWidth*0.35);
  g1.addColorStop(0, 'rgba(180,200,255,0.9)');
  g1.addColorStop(0.4,'rgba(140,100,255,0.6)');
  g1.addColorStop(0.7,'rgba(50,20,80,0.15)');
  g1.addColorStop(1, 'rgba(0,0,0,0)');
  cx.fillStyle = g1;
  cx.beginPath();
  cx.arc(cxMid, cyMid, innerWidth*0.4, 0, Math.PI*2);
  cx.fill();

  // tia s√°ng ki·ªÉu sao
  cx.save();
  cx.translate(cxMid, cyMid);
  cx.globalAlpha = 0.6;

  function starRay(angle, w, len){
    cx.save();
    cx.rotate(angle);
    const grd = cx.createLinearGradient(0,0,0,len);
    grd.addColorStop(0,'rgba(255,255,255,0.9)');
    grd.addColorStop(1,'rgba(255,255,255,0)');
    cx.fillStyle = grd;
    cx.beginPath();
    cx.moveTo(-w,0);
    cx.lineTo(w,0);
    cx.lineTo(0,len);
    cx.closePath();
    cx.fill();
    cx.restore();
  }

  const baseLen = Math.min(innerWidth,innerHeight)*0.28;
  const baseW   = baseLen*0.03;
  starRay(0,             baseW,     baseLen);
  starRay(Math.PI/2,     baseW,     baseLen);
  starRay(Math.PI/4,     baseW*0.7, baseLen*0.7);
  starRay(3*Math.PI/4,   baseW*0.7, baseLen*0.7);

  cx.restore();

  // l√µi s√°ng tr·∫Øng nh·ªè
  const g2 = cx.createRadialGradient(cxMid, cyMid, 0, cxMid, cyMid, 40);
  g2.addColorStop(0,'rgba(255,255,255,1)');
  g2.addColorStop(1,'rgba(255,255,255,0)');
  cx.fillStyle = g2;
  cx.beginPath();
  cx.arc(cxMid, cyMid, 40, 0, Math.PI*2);
  cx.fill();
}

// v·∫Ω 1 card ·∫£nh bo g√≥c
function drawCardImage(img, x, y, w, h, rr, border=false, scaleAlpha=1){
  cx.save();
  cx.translate(x, y);

  // n·ªÅn card
  if (border) {
    // spotlight card: n·ªÅn t·ªëi + vi·ªÅn h·ªìng
    cx.fillStyle = 'rgba(0,0,0,0.6)';
    roundRect(cx, -w/2, -h/2, w, h, rr);
    cx.fill();

    cx.lineWidth = Math.max(2, 4*scaleAlpha/3);
    cx.strokeStyle = 'rgba(255,120,200,0.6)';
    roundRect(cx, -w/2, -h/2, w, h, rr);
    cx.stroke();
  } else {
    // orbit card: 1 l·ªõp m·ªù nh·∫π
    cx.fillStyle = 'rgba(255,255,255,0.15)';
    roundRect(cx, -w/2, -h/2, w, h, rr);
    cx.fill();
  }

  // actual image
  if (img && img.complete && w>2 && h>2){
    cx.save();
    roundRect(cx, -w/2, -h/2, w, h, rr);
    cx.clip();
    cx.drawImage(img, -w/2, -h/2, w, h);
    cx.restore();
  }

  cx.restore();
}

function renderLoop(){
  requestAnimationFrame(renderLoop);

  if (!spriteImgs.length || !sprites.length) {
    // n·∫øu ch∆∞a load ·∫£nh xong th√¨ t·∫°m clear n·ªÅn ƒëen cho ƒë·∫πp
    cx.fillStyle = "#000";
    cx.fillRect(0,0,innerWidth,innerHeight);
    return;
  }

  // === update state orbit/spotlight ===
  if (mode === "orbit"){
    tOrbit += 1;
    userRotY += autoSpeed;
    orbitFrameCounter++;

    if (orbitFrameCounter >= ORBIT_FRAMES_BEFORE_SPOTLIGHT){
      mode = "spotlight";
      orbitFrameCounter = 0;
      spotlightFrameCounter = 0;

      // sprite hi·ªán t·∫°i (slot)
      const curSlot = spotlightSpriteIndex % sprites.length;
      const sp = sprites[curSlot];

      // ch·ª•p scale v√† imgIndex l√∫c n√†y
      const angNow = sp.baseA + tOrbit*(0.028 + sp.s*0.004);
      const px3 = Math.cos(angNow)*sp.r;
      const pz3 = Math.sin(angNow)*sp.r;
      const py3 = sp.y;
      const screen = proj(px3, py3, pz3);

      spotlightImageScale = sp.s * screen.s || 1;

      // kh√¥ng ƒë·ªïi spotlightSpriteIndex (v·∫´n l√† curSlot)
      spotlightSpriteIndex = curSlot;

      // ti·∫øp theo s·∫Ω l√† slot k·∫ø ti·∫øp
      nextSpotlightSpriteIndex = (curSlot + 1) % sprites.length;
    }

  } else if (mode === "spotlight"){
    // ƒë·ª©ng im
    spotlightFrameCounter++;
    if (spotlightFrameCounter >= SPOTLIGHT_FRAMES){
      mode = "orbit";
      spotlightSpriteIndex = nextSpotlightSpriteIndex;
    }
  }

  // === v·∫Ω n·ªÅn gradient v≈© tr·ª• ===
  const gx = innerWidth*0.6;
  const gy = innerHeight*0.5;
  const gr = Math.max(innerWidth,innerHeight);
  const bg = cx.createRadialGradient(gx,gy,0,gx,gy,gr);
  bg.addColorStop(0,'rgba(20,30,60,0.55)');
  bg.addColorStop(0.6,'rgba(10,8,20,0.9)');
  bg.addColorStop(1,'rgba(0,0,0,1)');
  cx.fillStyle = bg;
  cx.fillRect(0,0,innerWidth,innerHeight);

  // tia s√°ng trung t√¢m + glow m√†u
  drawCoreGlow();

  // sao xa
  cx.globalAlpha = 0.7;
  cx.fillStyle = '#ffffff';
  for(const s of stars){
    const p2 = proj(s.x, s.y, s.z);
    const rStar = Math.max(.4, 1.2*p2.s);
    cx.beginPath();
    cx.arc(p2.x, p2.y, rStar, 0, Math.PI*2);
    cx.fill();
  }
  cx.globalAlpha = 1;

  // d·∫£i ng√¢n h√† (b·ª•i m√†u)
  let drawList = points;
  if((sortToggle ^= 1)){
    drawList = points.slice().sort((a,b)=>{
      const za = a.x*Math.sin(userRotY)+a.z*Math.cos(userRotY);
      const zb = b.x*Math.sin(userRotY)+b.z*Math.cos(userRotY);
      return za - zb;
    });
  }
  const pulseAmt = pulsing ? (1 + Math.sin(tOrbit*0.06)*0.06) : 1;
  for(const p0 of drawList){
    const wobble = Math.sin((p0.x+p0.z+tOrbit*0.8)*0.01)*0.5;
    const pr = proj(
      p0.x * pulseAmt,
      (p0.y + wobble) * pulseAmt,
      p0.z * pulseAmt
    );
    const hue  = (p0.hueBase + 20*Math.sin(tOrbit*0.02)) % 360;
    const size = Math.min(2.8, 1.8*pr.s + 0.6);

    cx.fillStyle = `hsla(${hue}, ${p0.sat}%, ${p0.light}%, 0.9)`;
    cx.beginPath();
    cx.arc(pr.x, pr.y, size, 0, Math.PI*2);
    cx.fill();
  }

  // === v·∫Ω sprites (·∫£nh quay / spotlight) ===
  if (mode === "spotlight"){
    // overlay t·ªëi nh·∫π ƒë·ªÉ l√†m n·ªïi t·∫•m ·∫£nh spotlight
    cx.save();
    cx.fillStyle = 'rgba(0,0,0,0.4)';
    cx.fillRect(0,0,innerWidth,innerHeight);
    cx.restore();

    // sprite slot ƒë∆∞·ª£c spotlight
    const slot = sprites[spotlightSpriteIndex];
    const img  = spriteImgs[slot.imgIndex % spriteImgs.length];

    const scaleNow = (spotlightImageScale || 1) * 3;
    const w = 110 * scaleNow;
    const h = w;
    const rr = Math.min(18*scaleNow, w/4);

    drawCardImage(
      img,
      innerWidth/2,
      innerHeight/2,
      w,
      h,
      rr,
      true,          // border mode spotlight
      scaleNow
    );

  } else {
    // orbit mode
    for (let i=0;i<sprites.length;i++){
      const sp = sprites[i];

      const angNow = sp.baseA + tOrbit*(0.028 + sp.s*0.004);
      const px3 = Math.cos(angNow)*sp.r;
      const pz3 = Math.sin(angNow)*sp.r;
      const py3 = sp.y;

      const screen = proj(px3, py3, pz3);

      const scaleNow = sp.s * screen.s;
      const w = 80 * scaleNow;
      const h = w;
      const rr = Math.min(10*scaleNow, w/4);

      const img = spriteImgs[sp.imgIndex % spriteImgs.length];

      drawCardImage(
        img,
        screen.x,
        screen.y,
        w,
        h,
        rr,
        false,
        scaleNow
      );
    }
  }
}

/* =========================================================
   ========== 10. Kh·ªüi t·∫°o sprites sau khi load ·∫£nh =========
   ========================================================= */
async function init() {
  // 1) load ·∫£nh ng∆∞·ªùi d√πng t·ª´ indexedDB
  const galaxyURLs = await loadAllGalaxyImages(); // m·∫£ng URL objectURL/string
  // 2) t·∫°o Image() objects
  spriteImgs = galaxyURLs.map(src => {
    const im = new Image();
    im.src = src;
    return im;
  });

  // 3) t·∫°o m·∫£ng sprites (c√°c "th·∫ª" bay quanh)
  //    m·ªói sprite tr·ªè t·ªõi 1 imgIndex, l·∫∑p l·∫°i qua danh s√°ch ·∫£nh
  sprites = [];
  for(let i=0;i<ORBIT_SPRITES;i++){
    const a = i / ORBIT_SPRITES * Math.PI*2;
    const r = 280 + Math.sin(i*0.7)*18;
    sprites.push({
      imgIndex: i % spriteImgs.length,
      baseA: a,
      r,
      y: (Math.random()-0.5)*30,
      s: 0.9 + Math.random()*0.4
    });
  }

  // 4) start render loop
  renderLoop();
}

init();
</script>
</body>
</html>
