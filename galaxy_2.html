<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <title>Galaxy ‚Äî Birthday Orbit ‚ú®</title>
  <meta name="theme-color" content="#000000">
  <style>
    html, body {
      height:100%;
      margin:0;
      background:#000;
      overflow:hidden;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
    }

    #cv{
      position:fixed;
      inset:0;
      z-index:1;
      display:block;
    }

    #wishBox{
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:24px;
      text-align:center;

      font-family: "Dancing Script", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
      font-size:clamp(24px,4vw,40px);
      line-height:1.3;
      color:#fff;

      text-shadow:
        0 0 12px rgba(255,100,200,1),
        0 0 28px rgba(255,0,120,0.8),
        0 4px 10px rgba(0,0,0,.8);

      background: radial-gradient(
        circle at 50% 50%,
        rgba(0,0,0,0.6) 0%,
        rgba(0,0,0,0.0) 60%
      );

      pointer-events:none;
      opacity:0;
      transition: opacity .8s ease;
      z-index:5;
    }
  </style>
</head>
<body>

  <div id="wishBox"></div>
  <canvas id="cv"></canvas>

<script>
/* ================== LOAD DATA T·ª™ LOCALSTORAGE ================== */
const savedWish = localStorage.getItem("wish_text")
  || "Ch√∫c m·ª´ng sinh nh·∫≠t üéÇ Ch√∫c b·∫°n lu√¥n xinh ƒë·∫πp, h·∫°nh ph√∫c v√† ƒë∆∞·ª£c y√™u th∆∞∆°ng nh·∫•t v≈© tr·ª• üíñ‚ú®";

document.getElementById('wishBox').textContent = savedWish;
setTimeout(()=> {
  document.getElementById('wishBox').style.opacity = 1;
}, 10000);

// L·∫•y danh s√°ch ·∫£nh nhi·ªÅu t·∫•m:
let IMAGE_URLS = [];
try {
  const fromLS = JSON.parse(localStorage.getItem("galaxy_imgs"));
  if (Array.isArray(fromLS) && fromLS.length > 0) {
    IMAGE_URLS = fromLS;
  } else {
    // fallback n·∫øu kh√¥ng c√≥
    IMAGE_URLS = [
      "assets/cute-cake.png",
      "assets/card-cute.jpg"
    ];
  }
} catch(e){
  IMAGE_URLS = [
    "assets/cute-cake.png",
    "assets/card-cute.jpg"
  ];
}

/* ================== CANVAS SETUP ================== */
const cv = document.getElementById('cv');
const cx = cv.getContext('2d', { alpha: false });

let DPR = Math.min((window.devicePixelRatio||1), 1.75);
function resize(){
  cv.width  = Math.max(1, Math.floor(innerWidth  * DPR));
  cv.height = Math.max(1, Math.floor(innerHeight * DPR));
  cv.style.width  = innerWidth + 'px';
  cv.style.height = innerHeight + 'px';
  cx.setTransform(DPR,0,0,DPR,0,0);
}
addEventListener('resize', resize);
resize();

/* ================== PERF PRESET ================== */
const mem = navigator.deviceMemory || 4;
const LOW = mem <= 4 && innerWidth < 900;

const STAR_COUNT    = LOW ? 1800 : 3200;
const R_MAX         = 420;
const THICKNESS     = 22;

// s·ªë khung ·∫£nh quay quanh (c√≥ th·ªÉ > s·ªë ·∫£nh, s·∫Ω l·∫∑p)
const ORBIT_SPRITES = 8;

/* ================== CAMERA / STATE ================== */
let autoSpeed = 0.01;
let userRotY = 0.0;
let userRotX = 0.18;
const dist = 520;

/* ================== GALAXY POINT CLOUD ================== */
const points = [];
for (let i=0; i<STAR_COUNT; i++){
  const radius    = Math.pow(Math.random(), 0.55) * R_MAX;
  const arms      = 4;
  const baseAngle = Math.random() * Math.PI * 2;
  const twist     = radius * 0.17;
  const angle     = baseAngle
                  + Math.floor(Math.random()*arms) * (Math.PI*2/arms)
                  + twist;

  const y = (Math.random()-0.5) * THICKNESS;
  const x = Math.cos(angle) * radius;
  const z = Math.sin(angle) * radius;

  const hueBase = 200 + (angle/(Math.PI*2))*120;
  const sat     = 88;
  const light   = 55 + Math.random()*12;

  points.push({x,y,z,hueBase,sat,light});
}

/* ================== BACKGROUND STARS ================== */
const stars = Array.from({length: LOW ? 900 : 1400}, () => ({
  x:(Math.random()-0.5)*2600,
  y:(Math.random()-0.5)*1600,
  z: Math.random()*2400 + 400
}));

/* ================== LOAD T·∫§T C·∫¢ ·∫¢NH TH√ÄNH Image() ================== */
const spriteImgs = IMAGE_URLS.map(url => {
  const im = new Image();
  im.src = url;
  return im;
});

/* ================== T·∫†O DANH S√ÅCH SPRITES QUAY ================== */
const sprites = [];
for(let i=0;i<ORBIT_SPRITES;i++){
  const a = i / ORBIT_SPRITES * Math.PI*2;
  const r = 280 + Math.sin(i*0.7)*18;

  // l·∫∑p qua danh s√°ch ·∫£nh: 0..len-1..0..len-1...
  const imgIndex = i % spriteImgs.length;

  sprites.push({
    baseA: a,
    r,
    y: (Math.random()-0.5)*30,
    s: 0.9 + Math.random()*0.4,
    imgIndex
  });
}

/* ================== INTERACTION DRAG ================== */
let dragging=false, px=0, py=0;

cv.addEventListener('mousedown', e=>{
  dragging=true; px=e.clientX; py=e.clientY;
});
addEventListener('mouseup', ()=> dragging=false);
addEventListener('mousemove', e=>{
  if(!dragging) return;
  const dx=e.clientX-px, dy=e.clientY-py;
  px=e.clientX; py=e.clientY;
  userRotY += dx*0.006;
  userRotX += dy*0.006;
  userRotX = Math.max(-1.2, Math.min(1.2, userRotX));
});

cv.addEventListener('touchstart', e=>{
  if(e.touches.length===1){
    dragging=true;
    px=e.touches[0].clientX;
    py=e.touches[0].clientY;
  }
},{passive:true});

cv.addEventListener('touchmove', e=>{
  if(e.touches.length===1 && dragging){
    const t0=e.touches[0];
    const dx=t0.clientX-px, dy=t0.clientY-py;
    px=t0.clientX; py=t0.clientY;
    userRotY+=dx*0.006;
    userRotX+=dy*0.006;
    userRotX=Math.max(-1.2,Math.min(1.2,userRotX));
  }
},{passive:true});

cv.addEventListener('touchend', ()=>{
  dragging=false;
},{passive:true});

/* ================== PROJECTION ================== */
function proj(x,y,z){
  const cY = Math.cos(userRotY), sY = Math.sin(userRotY);
  const cX = Math.cos(userRotX), sX = Math.sin(userRotX);

  let X = x*cY - z*sY;
  let Z = x*sY + z*cY;
  let Y = y*cX - Z*sX;
  Z = y*sX + Z*cX + dist;

  const f = 450 / Z;
  return {
    x: innerWidth/2  + X*f,
    y: innerHeight/2 + Y*f,
    s: f
  };
}

/* ================== SPOTLIGHT STATE ================== */
let mode = "orbit";
let tOrbit = 0;
let orbitFrameCounter = 0;
const ORBIT_FRAMES_BEFORE_SPOTLIGHT = 20; // ~4s quay tr∆∞·ªõc khi spotlight

let spotlightFrameCounter = 0;
const SPOTLIGHT_FRAMES = 10; // ~2s spotlight

let spotlightSpriteIndex = 0;
let spotlightSpriteIndexNext = 1;

let spotlightImageScale = 1;

/* ================== LOOP ================== */
let sortToggle = 0;
let pulsing = false;

(function loop(){
  requestAnimationFrame(loop);

  // c·∫≠p nh·∫≠t logic orbit/spotlight
  if (mode === "orbit"){
    tOrbit += 1;
    userRotY += 0.01;
    orbitFrameCounter++;

    if (orbitFrameCounter >= ORBIT_FRAMES_BEFORE_SPOTLIGHT){
      mode = "spotlight";
      orbitFrameCounter = 0;
      spotlightFrameCounter = 0;

      const curIdx = spotlightSpriteIndex % sprites.length;
      const sp = sprites[curIdx];

      // ch·ª•p scale t·∫°i v·ªã tr√≠ hi·ªán t·∫°i
      const angNow = sp.baseA + tOrbit*(0.028 + sp.s*0.004);
      const px3 = Math.cos(angNow)*sp.r;
      const pz3 = Math.sin(angNow)*sp.r;
      const py3 = sp.y;
      const screen = proj(px3, py3, pz3);
      spotlightImageScale = sp.s * screen.s || 1;

      spotlightSpriteIndex = curIdx;
      spotlightSpriteIndexNext = (curIdx + 1) % sprites.length;
    }

  } else if (mode === "spotlight"){
    spotlightFrameCounter++;
    if (spotlightFrameCounter >= SPOTLIGHT_FRAMES){
      mode = "orbit";
      spotlightSpriteIndex = spotlightSpriteIndexNext;
    }
  }

  // v·∫Ω n·ªÅn gradient galaxy
  const gx = innerWidth*0.6;
  const gy = innerHeight*0.5;
  const gr = Math.max(innerWidth,innerHeight);
  const bg = cx.createRadialGradient(gx,gy,0,gx,gy,gr);
  bg.addColorStop(0,'rgba(20,30,60,0.55)');
  bg.addColorStop(0.6,'rgba(10,8,20,0.9)');
  bg.addColorStop(1,'rgba(0,0,0,1)');
  cx.fillStyle = bg;
  cx.fillRect(0,0,innerWidth,innerHeight);

  // glow l√µi + tia s√°ng
  (function drawCoreGlow(){
    const cxMid = innerWidth/2;
    const cyMid = innerHeight/2;

    const g1 = cx.createRadialGradient(
      cxMid, cyMid, 0,
      cxMid, cyMid, innerWidth*0.35
    );
    g1.addColorStop(0, 'rgba(180,200,255,0.9)');
    g1.addColorStop(0.4,'rgba(140,100,255,0.6)');
    g1.addColorStop(0.7,'rgba(50,20,80,0.15)');
    g1.addColorStop(1, 'rgba(0,0,0,0)');
    cx.fillStyle = g1;
    cx.beginPath();
    cx.arc(cxMid, cyMid, innerWidth*0.4, 0, Math.PI*2);
    cx.fill();

    cx.save();
    cx.translate(cxMid, cyMid);
    cx.globalAlpha = 0.6;

    function starRay(angle, w, len){
      cx.save();
      cx.rotate(angle);
      const grd = cx.createLinearGradient(0,0,0,len);
      grd.addColorStop(0,'rgba(255,255,255,0.9)');
      grd.addColorStop(1,'rgba(255,255,255,0)');
      cx.fillStyle = grd;
      cx.beginPath();
      cx.moveTo(-w,0);
      cx.lineTo(w,0);
      cx.lineTo(0,len);
      cx.closePath();
      cx.fill();
      cx.restore();
    }

    const baseLen = Math.min(innerWidth,innerHeight)*0.28;
    const baseW   = baseLen*0.03;

    starRay(0,             baseW,     baseLen);
    starRay(Math.PI/2,     baseW,     baseLen);
    starRay(Math.PI/4,     baseW*0.7, baseLen*0.7);
    starRay(3*Math.PI/4,   baseW*0.7, baseLen*0.7);

    cx.restore();

    const g2 = cx.createRadialGradient(cxMid, cyMid, 0, cxMid, cyMid, 40);
    g2.addColorStop(0,'rgba(255,255,255,1)');
    g2.addColorStop(1,'rgba(255,255,255,0)');
    cx.fillStyle = g2;
    cx.beginPath();
    cx.arc(cxMid, cyMid, 40, 0, Math.PI*2);
    cx.fill();
  })();

  // sao n·ªÅn xa
  cx.globalAlpha = 0.7;
  cx.fillStyle = '#ffffff';
  for(const s of stars){
    const p2 = proj(s.x, s.y, s.z);
    const rStar = Math.max(.4, 1.2*p2.s);
    cx.beginPath();
    cx.arc(p2.x, p2.y, rStar, 0, Math.PI*2);
    cx.fill();
  }
  cx.globalAlpha = 1;

  // ng√¢n h√† h·∫°t
  let drawList = points;
  if((sortToggle ^= 1)){
    drawList = points.slice().sort((a,b)=>{
      const za = a.x*Math.sin(userRotY)+a.z*Math.cos(userRotY);
      const zb = b.x*Math.sin(userRotY)+b.z*Math.cos(userRotY);
      return za - zb;
    });
  }

  const pulseAmt = pulsing ? (1 + Math.sin(tOrbit*0.06)*0.06) : 1;

  for(const p0 of drawList){
    const wobble = Math.sin((p0.x+p0.z+tOrbit*0.8)*0.01)*0.5;
    const pr = proj(
      p0.x * pulseAmt,
      (p0.y + wobble) * pulseAmt,
      p0.z * pulseAmt
    );

    const hue  = (p0.hueBase + 20*Math.sin(tOrbit*0.02)) % 360;
    const size = Math.min(2.8, 1.8*pr.s + 0.6);

    cx.fillStyle = `hsla(${hue}, ${p0.sat}%, ${p0.light}%, 0.9)`;
    cx.beginPath();
    cx.arc(pr.x, pr.y, size, 0, Math.PI*2);
    cx.fill();
  }

  // v·∫Ω sprite: orbit vs spotlight
  if (mode === "spotlight"){
    // n·ªÅn t·ªëi ph·ªß m·ªù
    cx.save();
    cx.fillStyle = 'rgba(0,0,0,0.4)';
    cx.fillRect(0,0,innerWidth,innerHeight);
    cx.restore();

    const sp = sprites[spotlightSpriteIndex];
    const img = spriteImgs[sp.imgIndex];

    const scaleNow = (spotlightImageScale || 1) * 3;
    const w = 110 * scaleNow;
    const h = w;
    const rr = Math.min(18*scaleNow, w/4);

    cx.save();
    cx.translate(innerWidth/2, innerHeight/2);

    cx.fillStyle = 'rgba(0,0,0,0.6)';
    roundRect(cx, -w/2, -h/2, w, h, rr);
    cx.fill();

    cx.lineWidth = Math.max(2, 4*scaleNow/3);
    cx.strokeStyle = 'rgba(255,120,200,0.6)';
    roundRect(cx, -w/2, -h/2, w, h, rr);
    cx.stroke();

    if (img && img.complete && w>2 && h>2){
      cx.save();
      roundRect(cx, -w/2, -h/2, w, h, rr);
      cx.clip();
      cx.drawImage(img, -w/2, -h/2, w, h);
      cx.restore();
    }

    cx.restore();

  } else {
    // orbit mode: t·∫•t c·∫£ quay quanh
    for (let i=0;i<sprites.length;i++){
      const sp = sprites[i];
      const img = spriteImgs[sp.imgIndex];

      const angNow = sp.baseA + tOrbit*(0.028 + sp.s*0.004);
      const px3 = Math.cos(angNow)*sp.r;
      const pz3 = Math.sin(angNow)*sp.r;
      const py3 = sp.y;

      const screen = proj(px3, py3, pz3);

      const scaleNow = sp.s * screen.s;
      const w = 80 * scaleNow;
      const h = w;
      const rr = Math.min(10*scaleNow, w/4);

      cx.save();
      cx.translate(screen.x, screen.y);

      cx.fillStyle = 'rgba(255,255,255,0.15)';
      roundRect(cx, -w/2, -h/2, w, h, rr);
      cx.fill();

      if (img && img.complete && w>2 && h>2){
        cx.save();
        roundRect(cx, -w/2, -h/2, w, h, rr);
        cx.clip();
        cx.drawImage(img, -w/2, -h/2, w, h);
        cx.restore();
      }

      cx.restore();
    }
  }

})(); // end loop

/* ================== HELPER ================== */
function roundRect(ctx, x, y, w, h, r){
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y,   x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x,   y+h, r);
  ctx.arcTo(x,   y+h, x,   y,   r);
  ctx.arcTo(x,   y,   x+w, y,   r);
  ctx.closePath();
}
</script>
</body>
</html>
